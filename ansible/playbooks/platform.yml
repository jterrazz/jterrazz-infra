---
# Platform Services Playbook
# Bootstraps ArgoCD via Helm, then lets ArgoCD manage everything
# All kubectl/helm commands run ON the VPS (no external k8s API access needed)

- name: Platform Services Deployment
  hosts: all
  become: true
  gather_facts: true

  vars:
    environment: "{{ environment_type | default('local') }}"
    argocd_namespace: platform-gitops
    argocd_version: "9.3.5"
    kubeconfig_remote: /etc/rancher/k3s/k3s.yaml
    manifest_dest: /tmp/k8s-manifests
    templates_dir: "{{ playbook_dir }}/../templates"

  tasks:
    - name: Wait for Traefik to be ready
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl wait --for=condition=complete job -l helmcharts.helm.cattle.io/chart=traefik -n kube-system --timeout=1s
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: traefik_wait
      retries: 60
      delay: 2
      until: traefik_wait.rc == 0
      changed_when: false

    # Copy infrastructure manifests to VPS
    - name: Create manifest directory on VPS
      ansible.builtin.file:
        path: "{{ manifest_dest }}"
        state: directory
        mode: "0755"

    - name: Copy infrastructure manifests to VPS
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../../kubernetes/"
        dest: "{{ manifest_dest }}/kubernetes/"
        mode: "0644"

    # Get Tailscale IP for registry ingress
    - name: Get Tailscale IP
      ansible.builtin.command: tailscale ip -4
      register: platform_tailscale_ip_result
      changed_when: false

    - name: Set Tailscale IP fact
      ansible.builtin.set_fact:
        tailscale_ip: "{{ platform_tailscale_ip_result.stdout | trim }}"

    # Registry secrets from Pulumi (registry_password must be passed as extra var)
    - name: Install apache2-utils for htpasswd
      ansible.builtin.apt:
        name: apache2-utils
        state: present
        update_cache: true
      when: registry_password is defined and registry_password | length > 0

    - name: Generate htpasswd hash for registry
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          htpasswd -nbB deploy "{{ registry_password }}"
        executable: /bin/bash
      register: htpasswd_result
      changed_when: false
      no_log: true
      when: registry_password is defined and registry_password | length > 0

    - name: Set registry facts
      ansible.builtin.set_fact:
        registry_htpasswd: "{{ htpasswd_result.stdout | trim }}"
        server_ip: "{{ hostvars[inventory_hostname]['ansible_host'] | default(ansible_default_ipv4.address) }}"
      when: registry_password is defined and registry_password | length > 0
      no_log: true

    - name: Template registry manifest with secrets
      ansible.builtin.template:
        src: "{{ templates_dir }}/kubernetes/registry.yaml.j2"
        dest: "{{ manifest_dest }}/kubernetes/platform/registry.yaml"
        mode: "0644"
      when: registry_password is defined and registry_password | length > 0

    - name: Template registry pull secret for app namespaces
      ansible.builtin.template:
        src: "{{ templates_dir }}/kubernetes/registry-pull-secret.yaml.j2"
        dest: "{{ manifest_dest }}/registry-pull-secret.yaml"
        mode: "0644"
      when: registry_password is defined and registry_password | length > 0

    - name: Apply registry pull secret
      ansible.builtin.command: kubectl apply -f {{ manifest_dest }}/registry-pull-secret.yaml
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      when: registry_password is defined and registry_password | length > 0
      register: pull_secret_result
      changed_when: "'created' in pull_secret_result.stdout or 'configured' in pull_secret_result.stdout"

    # Make released PVs available for rebinding (for data persistence across redeployments)
    - name: Clear claimRef from released PVs
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          for pv in $(kubectl get pv -o jsonpath='{.items[?(@.status.phase=="Released")].metadata.name}'); do
            kubectl patch pv $pv -p '{"spec":{"claimRef":null}}' --type=merge
          done
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: pv_clear
      changed_when: pv_clear.stdout != ''
      failed_when: false

    # Apply base infrastructure (namespaces, network policies, storage config)
    - name: Deploy base infrastructure manifests
      ansible.builtin.command:
        cmd: kubectl apply -k {{ manifest_dest }}/kubernetes/infrastructure/environments/{{ environment }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: infra_result
      changed_when: "'created' in infra_result.stdout or 'configured' in infra_result.stdout"

    # Install Helm on VPS if not present
    - name: Check if Helm is installed
      ansible.builtin.command: which helm
      register: helm_check
      changed_when: false
      failed_when: false

    - name: Install Helm
      when: helm_check.rc != 0
      block:
        - name: Download Helm install script
          ansible.builtin.get_url:
            url: https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
            dest: /tmp/get_helm.sh
            mode: "0755"

        - name: Run Helm install script
          ansible.builtin.command: /tmp/get_helm.sh
          environment:
            DESIRED_VERSION: v3.14.0
          changed_when: true

        - name: Cleanup Helm install script
          ansible.builtin.file:
            path: /tmp/get_helm.sh
            state: absent

    # Bootstrap ArgoCD via Helm
    - name: Add ArgoCD Helm repository
      ansible.builtin.command: helm repo add argo https://argoproj.github.io/argo-helm
      register: repo_add
      changed_when: "'has been added' in repo_add.stdout"
      failed_when: false

    - name: Update Helm repositories
      ansible.builtin.command: helm repo update
      changed_when: false

    - name: Check if ArgoCD is already installed
      ansible.builtin.command: helm status argocd -n {{ argocd_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: argocd_status
      changed_when: false
      failed_when: false

    - name: Create ArgoCD namespace
      ansible.builtin.command: kubectl create namespace {{ argocd_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: ns_create
      changed_when: "'created' in ns_create.stdout"
      failed_when: false

    - name: Create ArgoCD Helm values file
      ansible.builtin.copy:
        dest: /tmp/argocd-values.yaml
        mode: "0644"
        content: |
          configs:
            params:
              server.insecure: true
          server:
            resources:
              requests:
                cpu: 50m
                memory: 128Mi
              limits:
                memory: 256Mi
          redis:
            resources:
              requests:
                cpu: 10m
                memory: 64Mi
              limits:
                memory: 128Mi
          controller:
            resources:
              requests:
                cpu: 100m
                memory: 256Mi
              limits:
                memory: 512Mi
          repoServer:
            resources:
              requests:
                cpu: 50m
                memory: 128Mi
              limits:
                memory: 256Mi
          applicationSet:
            resources:
              requests:
                cpu: 10m
                memory: 64Mi
              limits:
                memory: 128Mi
          notifications:
            resources:
              requests:
                cpu: 10m
                memory: 32Mi
              limits:
                memory: 64Mi
          dex:
            resources:
              requests:
                cpu: 10m
                memory: 32Mi
              limits:
                memory: 64Mi

    - name: Install/Upgrade ArgoCD via Helm
      ansible.builtin.command: >
        helm upgrade --install argocd argo/argo-cd
        --namespace {{ argocd_namespace }}
        --version {{ argocd_version }}
        --values /tmp/argocd-values.yaml
        --wait
        --timeout 5m
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: helm_result
      changed_when: "'has been upgraded' in helm_result.stdout or 'has been installed' in helm_result.stdout"

    - name: Wait for ArgoCD to be ready
      ansible.builtin.command:
        cmd: kubectl rollout status deployment/argocd-server -n {{ argocd_namespace }} --timeout=120s
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      changed_when: false

    # Create namespaces for cert-manager and external-dns secrets
    - name: Create cert-manager namespace
      ansible.builtin.command: kubectl create namespace cert-manager
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: cm_ns
      changed_when: "'created' in cm_ns.stdout"
      failed_when: false

    - name: Create external-dns namespace
      ansible.builtin.command: kubectl create namespace external-dns
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: ed_ns
      changed_when: "'created' in ed_ns.stdout"
      failed_when: false

    # Deploy Cloudflare API token for cert-manager and external-dns
    - name: Create Cloudflare API token secret for cert-manager
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl create secret generic cloudflare-api-token \
            --from-literal=api-token="{{ cloudflare_api_token }}" \
            --namespace cert-manager \
            --dry-run=client -o yaml | kubectl apply -f -
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      when: cloudflare_api_token is defined and cloudflare_api_token | length > 0
      register: cm_secret
      changed_when: "'created' in cm_secret.stdout or 'configured' in cm_secret.stdout"
      no_log: true

    - name: Create Cloudflare API token secret for external-dns
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl create secret generic cloudflare-api-token \
            --from-literal=api-token="{{ cloudflare_api_token }}" \
            --namespace external-dns \
            --dry-run=client -o yaml | kubectl apply -f -
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      when: cloudflare_api_token is defined and cloudflare_api_token | length > 0
      register: ed_secret
      changed_when: "'created' in ed_secret.stdout or 'configured' in ed_secret.stdout"
      no_log: true

    - name: Create GitHub PAT secret for ArgoCD private repos
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl create secret generic github-private-repos \
            --from-literal=type=git \
            --from-literal=url=https://github.com/jterrazz \
            --from-literal=username=jterrazz \
            --from-literal=password="{{ github_pat }}" \
            --namespace {{ argocd_namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl label secret github-private-repos -n {{ argocd_namespace }} argocd.argoproj.io/secret-type=repo-creds --overwrite
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      when: github_pat is defined and github_pat | length > 0
      register: github_secret
      changed_when: "'created' in github_secret.stdout or 'configured' in github_secret.stdout"
      no_log: true

    # Create Infisical credentials for the secrets operator
    # Note: platform-secrets namespace is created by base infrastructure kustomization
    - name: Create Infisical credentials secret
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          kubectl create secret generic infisical-credentials \
            --from-literal=clientId="{{ infisical_client_id }}" \
            --from-literal=clientSecret="{{ infisical_client_secret }}" \
            --namespace platform-secrets \
            --dry-run=client -o yaml | kubectl apply -f -
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      when: infisical_client_id is defined and infisical_client_id | length > 0
      register: infisical_secret
      changed_when: "'created' in infisical_secret.stdout or 'configured' in infisical_secret.stdout"
      no_log: true

    # Apply platform services (ArgoCD Applications)
    # Each app has its own folder with *-app.yaml or app.yaml as Application manifests
    - name: Find platform service app manifests
      ansible.builtin.find:
        paths: "{{ manifest_dest }}/kubernetes/platform"
        patterns: "*app.yaml"
        recurse: true
      register: platform_apps

    - name: Apply platform services
      ansible.builtin.command: kubectl apply -f {{ item.path }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      loop: "{{ platform_apps.files }}"
      when: platform_apps.files | length > 0
      register: platform_result
      changed_when: "'created' in platform_result.stdout or 'configured' in platform_result.stdout"

    # Apply user applications
    - name: Find application manifests
      ansible.builtin.find:
        paths: "{{ manifest_dest }}/kubernetes/applications"
        patterns: "*.yml,*.yaml"
      register: argocd_apps

    - name: Apply ArgoCD applications
      ansible.builtin.command: kubectl apply -f {{ item.path }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      loop: "{{ argocd_apps.files }}"
      when: argocd_apps.files | length > 0
      register: apps_result
      changed_when: "'created' in apps_result.stdout or 'configured' in apps_result.stdout"

    # Cleanup
    - name: Cleanup temporary manifests
      ansible.builtin.file:
        path: "{{ manifest_dest }}"
        state: absent

    - name: Deployment complete
      ansible.builtin.debug:
        msg: |
          Platform deployment complete!

          ArgoCD: Bootstrapped via Helm v{{ argocd_version }}
          Platform services: {{ platform_apps.files | length }} registered
          Applications: {{ argocd_apps.files | length }} registered
