---
# Platform Services Playbook
# Bootstraps ArgoCD via Helm, then lets ArgoCD manage everything
# All kubectl/helm commands run ON the VPS (no external k8s API access needed)

- name: Platform Services Deployment
  hosts: all
  become: true
  gather_facts: true

  vars:
    env_type: "{{ environment_type | default('local') }}"
    argocd_namespace: platform-gitops
    argocd_version: "7.7.5"
    kubeconfig_remote: /etc/rancher/k3s/k3s.yaml
    manifest_dest: /tmp/k8s-manifests

  tasks:
    - name: Wait for Traefik to be ready
      ansible.builtin.shell: |
        kubectl wait --for=condition=complete job -l helmcharts.helm.cattle.io/chart=traefik -n kube-system --timeout=1s
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: traefik_wait
      retries: 60
      delay: 2
      until: traefik_wait.rc == 0
      changed_when: false

    # Copy infrastructure manifests to VPS
    - name: Create manifest directory on VPS
      ansible.builtin.file:
        path: "{{ manifest_dest }}"
        state: directory
        mode: "0755"

    - name: Copy infrastructure manifests to VPS
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../../kubernetes/"
        dest: "{{ manifest_dest }}/kubernetes/"
        mode: "0644"

    # Get Tailscale IP for DNS target annotation
    - name: Get Tailscale IP
      ansible.builtin.command: tailscale ip -4
      register: tailscale_ip_result
      changed_when: false

    - name: Set Tailscale IP fact
      ansible.builtin.set_fact:
        tailscale_ip: "{{ tailscale_ip_result.stdout | trim }}"

    # Template IngressRoutes with Tailscale IP for external-dns target
    - name: Template internal ingresses with Tailscale IP
      ansible.builtin.template:
        src: "{{ playbook_dir }}/../templates/kubernetes/internal-ingresses.yaml.j2"
        dest: "{{ manifest_dest }}/kubernetes/infrastructure/base/traefik/internal-ingresses.yaml"
        mode: "0644"

    # Make released PVs available for rebinding (for data persistence across redeployments)
    - name: Clear claimRef from released PVs
      ansible.builtin.shell: |
        for pv in $(kubectl get pv -o jsonpath='{.items[?(@.status.phase=="Released")].metadata.name}'); do
          kubectl patch pv $pv -p '{"spec":{"claimRef":null}}' --type=merge
        done
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: pv_clear
      changed_when: pv_clear.stdout != ''
      failed_when: false

    # Apply base infrastructure (namespaces, network policies, storage config)
    - name: Deploy base infrastructure manifests
      ansible.builtin.command:
        cmd: kubectl apply -k {{ manifest_dest }}/kubernetes/infrastructure/environments/{{ env_type }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: infra_result
      changed_when: "'created' in infra_result.stdout or 'configured' in infra_result.stdout"

    # Install Helm on VPS if not present
    - name: Check if Helm is installed
      ansible.builtin.command: which helm
      register: helm_check
      changed_when: false
      failed_when: false

    - name: Install Helm
      when: helm_check.rc != 0
      block:
        - name: Download Helm install script
          ansible.builtin.get_url:
            url: https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
            dest: /tmp/get_helm.sh
            mode: "0755"

        - name: Run Helm install script
          ansible.builtin.command: /tmp/get_helm.sh
          environment:
            DESIRED_VERSION: v3.14.0

        - name: Cleanup Helm install script
          ansible.builtin.file:
            path: /tmp/get_helm.sh
            state: absent

    # Bootstrap ArgoCD via Helm
    - name: Add ArgoCD Helm repository
      ansible.builtin.command: helm repo add argo https://argoproj.github.io/argo-helm
      register: repo_add
      changed_when: "'has been added' in repo_add.stdout"
      failed_when: false

    - name: Update Helm repositories
      ansible.builtin.command: helm repo update
      changed_when: false

    - name: Check if ArgoCD is already installed
      ansible.builtin.command: helm status argocd -n {{ argocd_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: argocd_status
      changed_when: false
      failed_when: false

    - name: Create ArgoCD namespace
      ansible.builtin.command: kubectl create namespace {{ argocd_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: ns_create
      changed_when: "'created' in ns_create.stdout"
      failed_when: false

    - name: Create ArgoCD Helm values file
      ansible.builtin.copy:
        dest: /tmp/argocd-values.yaml
        mode: "0644"
        content: |
          configs:
            params:
              server.insecure: true
          server:
            resources:
              requests:
                cpu: 50m
                memory: 128Mi
              limits:
                memory: 256Mi
          redis:
            resources:
              requests:
                cpu: 10m
                memory: 64Mi
              limits:
                memory: 128Mi
          controller:
            resources:
              requests:
                cpu: 100m
                memory: 256Mi
              limits:
                memory: 512Mi
          repoServer:
            resources:
              requests:
                cpu: 50m
                memory: 128Mi
              limits:
                memory: 256Mi
          applicationSet:
            resources:
              requests:
                cpu: 10m
                memory: 64Mi
              limits:
                memory: 128Mi
          notifications:
            resources:
              requests:
                cpu: 10m
                memory: 32Mi
              limits:
                memory: 64Mi
          dex:
            resources:
              requests:
                cpu: 10m
                memory: 32Mi
              limits:
                memory: 64Mi

    - name: Install/Upgrade ArgoCD via Helm
      ansible.builtin.command: >
        helm upgrade --install argocd argo/argo-cd
        --namespace {{ argocd_namespace }}
        --version {{ argocd_version }}
        --values /tmp/argocd-values.yaml
        --wait
        --timeout 5m
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: helm_result
      changed_when: "'has been upgraded' in helm_result.stdout or 'has been installed' in helm_result.stdout"

    - name: Wait for ArgoCD to be ready
      ansible.builtin.command:
        cmd: kubectl rollout status deployment/argocd-server -n {{ argocd_namespace }} --timeout=120s
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      changed_when: false

    # Create namespaces for cert-manager and external-dns secrets
    - name: Create cert-manager namespace
      ansible.builtin.command: kubectl create namespace cert-manager
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: cm_ns
      changed_when: "'created' in cm_ns.stdout"
      failed_when: false

    - name: Create external-dns namespace
      ansible.builtin.command: kubectl create namespace external-dns
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: ed_ns
      changed_when: "'created' in ed_ns.stdout"
      failed_when: false

    # Deploy Cloudflare API token for cert-manager and external-dns
    - name: Create Cloudflare API token secret for cert-manager
      ansible.builtin.shell: |
        kubectl create secret generic cloudflare-api-token \
          --from-literal=api-token="{{ cloudflare_api_token }}" \
          --namespace cert-manager \
          --dry-run=client -o yaml | kubectl apply -f -
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      when: cloudflare_api_token is defined and cloudflare_api_token | length > 0
      register: cm_secret
      changed_when: "'created' in cm_secret.stdout or 'configured' in cm_secret.stdout"
      no_log: true

    - name: Create Cloudflare API token secret for external-dns
      ansible.builtin.shell: |
        kubectl create secret generic cloudflare-api-token \
          --from-literal=api-token="{{ cloudflare_api_token }}" \
          --namespace external-dns \
          --dry-run=client -o yaml | kubectl apply -f -
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      when: cloudflare_api_token is defined and cloudflare_api_token | length > 0
      register: ed_secret
      changed_when: "'created' in ed_secret.stdout or 'configured' in ed_secret.stdout"
      no_log: true

    # Apply platform services (ArgoCD Applications)
    - name: Find platform service manifests
      ansible.builtin.find:
        paths: "{{ manifest_dest }}/kubernetes/platform"
        patterns: "*.yml,*.yaml"
      register: platform_apps

    - name: Apply platform services
      ansible.builtin.command: kubectl apply -f {{ item.path }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      loop: "{{ platform_apps.files }}"
      when: platform_apps.files | length > 0
      register: platform_result
      changed_when: "'created' in platform_result.stdout or 'configured' in platform_result.stdout"

    # Apply user applications
    - name: Find application manifests
      ansible.builtin.find:
        paths: "{{ manifest_dest }}/kubernetes/applications"
        patterns: "*.yml,*.yaml"
      register: argocd_apps

    - name: Apply ArgoCD applications
      ansible.builtin.command: kubectl apply -f {{ item.path }}
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      loop: "{{ argocd_apps.files }}"
      when: argocd_apps.files | length > 0
      register: apps_result
      changed_when: "'created' in apps_result.stdout or 'configured' in apps_result.stdout"

    # Cleanup
    - name: Cleanup temporary manifests
      ansible.builtin.file:
        path: "{{ manifest_dest }}"
        state: absent

    - name: Deployment complete
      ansible.builtin.debug:
        msg: |
          Platform deployment complete!

          ArgoCD: Bootstrapped via Helm v{{ argocd_version }}
          Platform services: {{ platform_apps.files | length }} registered
          Applications: {{ argocd_apps.files | length }} registered
